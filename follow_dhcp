#!/usr/bin/env php
<?php
// Parse command line arguments
$options = getopt('od', [
    'database:',
    'debug',
    'oneshot',
    'test',
]);

// Process data up to date (--oneshot) or follow log continuously (no arg)
$follow = !array_key_exists('oneshot', $options) && !array_key_exists('o', $options);
$debug = array_key_exists('debug', $options) || array_key_exists('d', $options);

require_once(__DIR__.'/lib/common.php');
if ($debug) print_r($GLOBALS);

// Database
$cursor = new SqlVar('dnsmasq_cursor', NULL);
$state = new SqlVar('visitor_state', [
    'ids' => [],
    'occupied' => 0,
]);

$add_visit = $db->prepare("
    INSERT INTO visit (mac, enter, leave, ip, hostname)
    VALUES (:mac,:now,:now,:ip,:host)
");
$update_visit = $db->prepare("
    UPDATE visit
    SET leave=:now
    WHERE leave>:now-:lease AND mac=:mac
");
$update_visit->bindValue('lease',$dhcp_lease_secs);
$find_users = $db->prepare("
	SELECT id, min(leave) AS leave
	FROM visit v
	JOIN user_mac m ON (SELECT rowid
	                    FROM user_mac
	                    WHERE mac=v.mac AND changed<v.leave
	                    ORDER BY changed DESC
	                    LIMIT 1
	                   )=m.rowid
	WHERE leave > ? AND id IS NOT NULL
	GROUP BY id
	ORDER BY id ASC
");

// Data source
$after = $cursor->get() === NULL ? '' : "'--after-cursor=".$cursor->get()."'";
$follow_arg = $follow ? '-f' : '';
$pipe = popen("exec journalctl -n all -u dnsmasq -o json $after $follow_arg", "r");
$min_leave = time(); // First we don't know, play sure and wait whole lease time.
if (array_key_exists('test', $options)) {
    print("Test mode, stopping\n");
    exit(0);
}

if (!$follow) $db->exec('BEGIN');

while (true) {
    // Wait for fresh data at most to next leaver deadline. If running
    // in one-shot mode, wait forever.
    while (true) {
        $delay = $follow ? max(0, $min_leave + $dhcp_lease_secs - time()) : INF;
        if ($debug) print("Waiting for data ".($delay === INF ? 'forever' : $delay.'s') ."...\n");

        if (!is_data_available($pipe, $delay)) {
            // First possible leaver timeout reached without getting
            // new data. Time to analyze the results.
            $last_event = time();
            break;
        }

        // Data is available. Parse journalctl entry.
        $line = fgets($pipe);
        if ($line === FALSE) {
            // Stop if EOF
            break 2;
        }
        $vars = json_decode($line);
        if ($vars === NULL) {
            print("Panic: Not systemd log export format\n");
            exit(1);
        }
    
        // Extract payload, if any.
        preg_match('/^[^ ]* DHCPACK[^ ]* ([^ ]*) ([^ ]*) ?(.*)/', $vars->MESSAGE, $matches);
        if (empty($matches)) {
            // This line is not interesting. Go get new
            continue;
        }
        
        // Populate all data and execute SQL
        $data = [
            'now' => floor($vars->__REALTIME_TIMESTAMP / 1000000), // seconds
            'mac' => strtoupper(str_replace(':', '', $matches[2])), // uppercase mac with no colons
            'ip' => $matches[1],
            'host' => $matches[3],
        ];
        if ($debug) var_dump($data);

        // Transaction starts here and lasts until cursor update. If
        // the script dies in a transaction, it can be safely restarted.
        if ($follow) $db->exec('BEGIN');
            
        // Try to update visit first if possible, otherwise insert new.
        db_execute($update_visit, $data);
        if ($db->changes() === 0) {
            db_execute($add_visit, $data);
        }

        // Store current journal cursor position
        $cursor->set($vars->__CURSOR);

        if ($follow) $db->exec('END');
        $last_event = $data['now']; // Use logbook date because we know it
        break; // Got new possibly relevant data, analyze it.
    }

    // Analyzing if anything changed. Get next potential leave time
    // and get list of persons on board.
    $users_result = db_execute($find_users, [$data['now'] - $dhcp_lease_secs]);
    $new_state = [
        'ts' => $last_event,
        'ids' => [],
        'occupied' => $state->get()['occupied'],
    ];

    $min_leave = INF;
    while (($row = $users_result->fetchArray(SQLITE3_ASSOC))) {
        // Grab them by the first leaver time
        $min_leave = min($min_leave, $row['leave']);
        array_push($new_state['ids'], $row['id']);
    }

    if ($state->get()['ids'] !== $new_state['ids']) {
        // Users changed. If it was previously empty, update time.
        if ($state->get()['ids'] === []) {
            $new_state['occupied'] = $min_leave;
        }

        $state->set($new_state);
        print($state->getRaw()."\n");
    } else {
        if ($debug) print("Checked data but no changes\n");
    }
}

if (!$follow) $db->exec('END');
