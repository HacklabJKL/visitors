#!/usr/bin/env php
<?php
require_once(__DIR__.'/common.php');
$dhcp_lease_secs = 300;

// Process data up to date (--oneshot) or follow log continuously (no args)
if (count($argv) < 2) {
    $follow = TRUE;
} else if ($argv[1] === "--oneshot") {
    $follow = FALSE;
} else {
    err("Invalid arguments");
}

// Database
$cursor = $db->querySingle("SELECT value FROM state WHERE key='cursor'");
$update_cursor = $db->prepare("UPDATE state SET value=? WHERE key='cursor'");
$add_visit = $db->prepare("INSERT INTO visit (mac, enter, leave, ip, hostname) VALUES (:mac,:now,:now,:ip,:host)");
$update_visit = $db->prepare("UPDATE visit SET leave=:now WHERE leave>:now-$dhcp_lease_secs AND mac=:mac");
$last_leave_rowid = $db->querySingle("SELECT value FROM state WHERE key='last_leave_rowid'");
$update_last_leave_rowid = $db->prepare("UPDATE state SET value=? WHERE key='last_leave_rowid'");
$potential_leave = $db->prepare("SELECT rowid, mac, leave FROM visit ORDER BY leave DESC limit 1;");

// 0MQ
/*$zmq_context = new ZMQContext();
$zmq_publisher = $zmq_context->getSocket(ZMQ::SOCKET_PUB);
$ipc_path = __DIR__.'/updates.ipc';
$zmq_publisher->bind("ipc://".$ipc_path);
chmod($ipc_path, 0777); // Allow access to all local users
*/

// Data source
$after = $cursor === NULL ? '' : "'--after-cursor=$cursor'";
$follow_arg = $follow ? '-f' : '';
$pipe = popen("journalctl -n all -u dnsmasq -o export $after $follow_arg", "r");

if (!$follow) $db->exec('BEGIN');

while (true) {
    // Calculate next potential leave time and wait until that to
    // decide if it the last person has left the premises.
    $leaver = db_execute($potential_leave)->fetchArray(SQLITE3_ASSOC);

    // Deciding how long to wait
    if ($leaver === FALSE || $leaver['rowid'] === $last_leave_rowid) {
        // Already reported or no data yet. Wait infinitely.
        $delay = NULL;
    } else {
        // Calculate waiting timeout. Always wait for new data for at
        // least a second (helps if processing historical data)
        $delay = max(1, $leaver['leave'] + $dhcp_lease_secs - gettimeofday(true));
    }

    if (!is_data_available($pipe, $delay)) {
        // No new data available. User has left.
        $last_leave_rowid = $leaver['rowid'];
        db_execute($update_last_leave_rowid, [$last_leave_rowid]);
        print("User ".$leaver['mac']." has left at ".$leaver['leave']."\n");
        continue; // Start again
    }

    $vars = [];
    while (true) {
        $line = fgets($pipe);
        if ($line === FALSE) {
            // It's over.
            break 2;
        } else if ($line === "\n") {
            break;
        } else {
            // Split the string and put to the storage
            $pos = strpos($line, '=');
            $vars[substr($line, 0, $pos)] = substr($line, $pos+1, strlen($line)-$pos-2);
        }
    }

    // Entry must contain cursor, timestamp, and message. If not, then
    // it's better to give up 'cause we have received garbage.
    if (!array_key_exists('MESSAGE', $vars) || !array_key_exists('__CURSOR', $vars) || !array_key_exists('__REALTIME_TIMESTAMP', $vars)) {
        print("Panic: Not systemd log export format\n");
        exit(1);
    }
    
    // Extract payload
    preg_match('/^[^ ]* DHCPACK[^ ]* ([^ ]*) ([^ ]*) ?(.*)/', $vars['MESSAGE'], $matches);

    // Transaction takes place until cursor update. If the script dies
    // while processing, it doesn't skip anything.
    if (!empty($matches)) {
        // We have a payload. Populate all data and execute SQL
        $data = [
            'now' => floor($vars['__REALTIME_TIMESTAMP'] / 1000000), // seconds
            'mac' => strtoupper(str_replace(':', '', $matches[2])), // uppercase mac with no colons
            'ip' => $matches[1],
            'host' => $matches[3],
        ];  

        if ($follow) $db->exec('BEGIN');

        // Try to update visit first if possible, otherwise insert new.
        db_execute($update_visit, $data);
        if ($db->changes() === 0) {
            db_execute($add_visit, $data);
        }

        // Store current journal cursor position
        db_execute($update_cursor, [$vars['__CURSOR']]);

        if ($follow) $db->exec('END');
    }

/*
    // After storing the data, notify. Other way around the long
    // poller might miss some data. And rowid wouldn't be available.
    if ($data !== NULL) {
        $out = implode(',',$data);
        $zmq_publisher->send($out);
        print($out."\n");
    }
*/
}

if (!$follow) $db->exec('END');
