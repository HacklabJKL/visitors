#!/usr/bin/env php
<?php
require_once(__DIR__.'/lib/common.php');
require_once(__DIR__.'/lib/irc.php');
require_once(__DIR__.'/lib/visitor_merge.php');

// Process data up to date (--oneshot) or follow log continuously (no args)
if (count($argv) < 2) {
    $follow = TRUE;
} else if ($argv[1] === "--oneshot") {
    $follow = FALSE;
} else {
    err("Invalid arguments");
}

// Database
$cursor = new SqlVar('cursor');
$last_leave = new SqlVar('last_leave');
$is_empty = new SqlVar('is_empty');
$add_visit = $db->prepare("
    INSERT INTO visit (mac, enter, leave, ip, hostname)
    VALUES (:mac,:now,:now,:ip,:host)
");
$update_visit = $db->prepare("
    UPDATE visit
    SET leave=:now
    WHERE leave>:now-:lease AND mac=:mac
");
$update_visit->bindValue('lease',$dhcp_lease_secs);
$find_leavers = $db->prepare("
	SELECT nick,enter,leave
	FROM visit v
	JOIN user_mac m ON (SELECT rowid
	                    FROM user_mac
	                    WHERE mac=v.mac AND changed<v.leave
	                    ORDER BY changed DESC
	                    LIMIT 1
	                   )=m.rowid
	JOIN user u ON m.id=u.id
	WHERE leave > ?
	ORDER BY leave DESC
");

function leave_line(&$a) {
    $msg = "Hacklab on nyt tyhjä. Paikalla oli";
    $msg .= count($a) > 1 ? 'vat ' : ' ';
    foreach ($a as $user => $visits) {
        $msg .= "$user (";
        foreach($visits as $visit) {
            $msg .=
                date('H:i', $visit['enter']).
                '–'.
                date('H:i', $visit['leave']).
                ', ';
        }
        // Add closing brace before comma+space the hard way
        $msg = substr($msg, 0, -2).'), ';
    }
    return substr($msg, 0, -2); // Remove comma+space
}

// Data source
$after = $cursor->v === NULL ? '' : "'--after-cursor=".$cursor->v."'";
$follow_arg = $follow ? '-f' : '';
$pipe = popen("journalctl -n all -u dnsmasq -o export $after $follow_arg", "r");

if (!$follow) $db->exec('BEGIN');

while (true) {
    // Calculate next potential leave time and wait until that to
    // decide if it the last person has left the premises.
    $leavers_result = db_execute($find_leavers, [$last_leave->v]);
    $last_visitor = $leavers_result->fetchArray(SQLITE3_ASSOC);

    // Deciding how long to wait
    if ( $last_visitor === FALSE ) {
        // Already reported or no data yet. Wait infinitely.
        $delay = NULL;
    } else {
        // Calculate waiting timeout. Always wait for new data for at
        // least a second (helps if processing historical data)
        $delay = max(1, $last_visitor['leave'] + $dhcp_lease_secs - time());

        // There is something to wait for. If this is the first time,
        // report it.
        if ($is_empty->v) {
            to_irc("Ensimmäisenä saapui ".$last_visitor['nick']);
        }
    }
    $is_empty->set($delay === NULL);

    if (!is_data_available($pipe, $delay)) {
        // No new data available. User has left. Set the empty state
        $last_leave->set($last_visitor['leave']);

        // Construct visitor list since last leave and send it to IRC.
        $a = [$last_visitor];
        while (($data = $leavers_result->fetchArray(SQLITE3_ASSOC))) {
            array_push($a, $data);
        }
        to_irc(leave_line(merge_visits($a)));

        continue; // Start again
    }

    // Parse journalctl entry to an associative array $vars
    $vars = [];
    while (true) {
        $line = fgets($pipe);
        if ($line === FALSE) {
            // It's over.
            break 2;
        } else if ($line === "\n") {
            break;
        } else {
            // Split the string and put to the storage
            $pos = strpos($line, '=');
            $vars[substr($line, 0, $pos)] = substr($line, $pos+1, strlen($line)-$pos-2);
        }
    }

    // Entry must contain cursor, timestamp, and message. If not, then
    // it's better to give up 'cause we have received garbage.
    if (
        !array_key_exists('MESSAGE', $vars) ||
        !array_key_exists('__CURSOR', $vars) ||
        !array_key_exists('__REALTIME_TIMESTAMP', $vars)
    ) {
        print("Panic: Not systemd log export format\n");
        exit(1);
    }
    
    // Extract payload
    preg_match('/^[^ ]* DHCPACK[^ ]* ([^ ]*) ([^ ]*) ?(.*)/', $vars['MESSAGE'], $matches);

    // Transaction takes place until cursor update. If the script dies
    // while processing, it doesn't skip anything.
    if (!empty($matches)) {
        // We have a payload. Populate all data and execute SQL
        $data = [
            'now' => floor($vars['__REALTIME_TIMESTAMP'] / 1000000), // seconds
            'mac' => strtoupper(str_replace(':', '', $matches[2])), // uppercase mac with no colons
            'ip' => $matches[1],
            'host' => $matches[3],
        ];

        if ($follow) $db->exec('BEGIN');

        // Try to update visit first if possible, otherwise insert new.
        db_execute($update_visit, $data);
        if ($db->changes() === 0) {
            db_execute($add_visit, $data);
        }

        // Store current journal cursor position
        $cursor->set($vars['__CURSOR']);

        if ($follow) $db->exec('END');
    }
}

if (!$follow) $db->exec('END');
